import {
  core.external {malloc},
  core.int {abs-int},
  core.memory {load-int, store-int},
  core.text {_from-c-string, _get-content-pointer, format, take},
  core.word,
}

foreign {
  clock_gettime(int, pointer): int,
  localtime(pointer): pointer,
  gmtime(pointer): pointer,
  mktime(pointer): pointer,
  timegm(pointer): pointer,
  snprintf(pointer, int, pointer): int,
  sprintf(pointer, pointer): int,
  strptime(pointer, pointer, pointer): pointer,
  neut_time_v0_4_parse_iso8601(pointer, pointer): int,
}

constant CLOCK_REALTIME: int {
  0
}

data time {
| Time(
    seconds: int,
    nanoseconds: int,
  )
}

data clock {
| Clock(
    nanoseconds: int,
    seconds: int,
    minutes: int,
    hours: int,
    day: int,
    month: int,
    year: int,
    weekday: int,
    yearday: int,
    is-dst: bool,
    gmt-offset: int,
    timezone: text,
  )
}

define _encode-dst(x: int): bool {
  if eq-int(x, 0) {
    False
  } else {
    True
  }
}

define _decode-dst(x: bool): int {
  if x {
    1
  } else {
    0
  }
}

define _from-time(t: time, interpreter: (int) -> int): clock {
  let Time of {seconds, nanoseconds} = t in
  let struct = magic alloca(int8, 16) in
  store-int(seconds, struct);
  store-int(nanoseconds, add-int(struct, 8));
  let localtime = interpreter(struct) in
  let nanoseconds: int = load-int(add-int(struct, 8)) in
  let seconds: int = magic load(int32, localtime) in
  let minutes: int = magic load(int32, add-int(localtime, 4)) in
  let hours: int = magic load(int32, add-int(localtime, 8)) in
  let day: int = magic load(int32, add-int(localtime, 12)) in
  let month: int = add-int(1, magic load(int32, add-int(localtime, 16))) in
  let year: int = add-int(1900, magic load(int32, add-int(localtime, 20))) in
  let weekday: int = magic load(int32, add-int(localtime, 24)) in
  let yearday: int = magic load(int32, add-int(localtime, 28)) in
  let is-dst = _encode-dst(magic load(int32, add-int(localtime, 32))) in
  let gmt-offset: int = magic load(int32, add-int(localtime, 40)) in
  let timezone: text = _from-c-string(magic load(int, add-int(localtime, 48))) in
  Clock of {
    nanoseconds,
    seconds,
    minutes,
    hours,
    day,
    month,
    year,
    weekday,
    yearday,
    is-dst,
    gmt-offset,
    timezone,
  }
}

define _from-clock(t: clock, interpreter: (int) -> int): time {
  use t {
    nanoseconds,
    seconds,
    minutes,
    hours,
    day,
    month,
    year,
    weekday,
    yearday,
    is-dst,
    gmt-offset,
    timezone,
  }
  in
  let timezone' on timezone = core.text.append(timezone, "\0") in
  let timezone-ptr on timezone' = _get-content-pointer(timezone') in
  let struct = magic alloca(int8, 56) in
  store-int(seconds, struct);
  store-int(minutes, add-int(struct, 4));
  store-int(hours, add-int(struct, 8));
  store-int(day, add-int(struct, 12));
  store-int(sub-int(month, 1), add-int(struct, 16));
  store-int(sub-int(year, 1900), add-int(struct, 20));
  store-int(weekday, add-int(struct, 24));
  store-int(yearday, add-int(struct, 28));
  store-int(_decode-dst(is-dst), add-int(struct, 32));
  store-int(gmt-offset, add-int(struct, 40));
  store-int(timezone-ptr, add-int(struct, 48));
  let _ = timezone in
  let _ = timezone' in
  let seconds = interpreter(struct) in
  Time of {seconds, nanoseconds}
}

define get-time(): time {
  let struct = magic alloca(int8, 16) in
  let result = magic external clock_gettime(CLOCK_REALTIME, struct) in
  if lt-int(result, 0) {
    panic("time.time.get-time(); `clock_gettime` failed\n")
  } else {
    let seconds: int = load-int(struct) in
    let nanoseconds: int = load-int(add-int(struct, 8)) in
    Time of {nanoseconds, seconds}
  }
}

define _mktime(ptr: int): int {
  magic external mktime(ptr)
}

define _timegm(ptr: int): int {
  magic external timegm(ptr)
}

define _localtime(ptr: int): int {
  magic external localtime(ptr)
}

define _gmtime(ptr: int): int {
  magic external gmtime(ptr)
}

define from-local-clock(t: clock): time {
  _from-clock(t, _mktime)
}

define from-UTC-clock(t: clock): time {
  _from-clock(t, _timegm)
}

define to-local-clock(t: time): clock {
  _from-time(t, _localtime)
}

define to-UTC-clock(t: time): clock {
  _from-time(t, _gmtime)
}

define _zeropad(x: int, format-text: &text): text {
  let fmt = _get-content-pointer(format-text) in
  let zero: int = 0 in
  let size: int = magic external snprintf(zero, zero, fmt)(x: int) in
  let ptr = malloc(add-int(size, add-int(1, mul-int(core.word.size, 2)))) in
  store-int(0, ptr);
  store-int(size, add-int(ptr, core.word.size));
  let buffer = add-int(ptr, mul-int(core.word.size, 2)) in
  let _: int = magic external sprintf(buffer, fmt)(x: int) in
  magic cast(int, text, ptr)
}

define _zeropad2(x: int): text {
  _zeropad(x, "%02ld")
}

define _zeropad9(x: int): text {
  _zeropad(x, "%09ld")
}

define _format-nanoseconds(nanoseconds: int, digits: int): text {
  if gt-int(digits, 0) {
    let result = _zeropad9(nanoseconds) in
    format(".{}", [take(digits, result)])
  } else {
    core.text.empty()
  }
}

define _format-gmt-offset(offset: int): text {
  if lt-int(offset, 0) {
    let offset = mul-int(offset, -1) in
    let hours = div-int(offset, mul-int(60, 60)) in
    let minutes = div-int(rem-int(offset, mul-int(60, 60)), 60) in
    format("-{}:{}", [_zeropad2(hours), _zeropad2(minutes)])
  } else-if lt-int(0, offset) {
    let hours = div-int(offset, mul-int(60, 60)) in
    let minutes = div-int(rem-int(offset, mul-int(60, 60)), 60) in
    format("+{}:{}", [_zeropad2(hours), _zeropad2(minutes)])
  } else {
    *"Z"
  }
}

inline _to-ISO8601(ts: time, nanosecond-digits: int, to-clock: (time) -> clock): text {
  let t = to-clock(ts) in
  let Clock of {nanoseconds, seconds, minutes, hours, day, month, year, gmt-offset} = t in
  format("{}-{}-{}T{}:{}:{}{}{}", [
    %ld(year),
    _zeropad2(month),
    _zeropad2(day),
    _zeropad2(hours),
    _zeropad2(minutes),
    _zeropad2(seconds),
    _format-nanoseconds(nanoseconds, nanosecond-digits),
    _format-gmt-offset(gmt-offset),
  ])
}

define to-ISO8601-local(ts: time, nanosecond-digits: int): text {
  _to-ISO8601(ts, nanosecond-digits, to-local-clock)
}

define to-ISO8601-UTC(ts: time, nanosecond-digits: int): text {
  _to-ISO8601(ts, nanosecond-digits, to-UTC-clock)
}

define from-ISO8601(datetime-text: &text): ?time {
  let time-struct = magic alloca(int8, 16) in
  let result: int32 =
    magic external neut_time_v0_4_parse_iso8601(
      _get-content-pointer(datetime-text),
      time-struct,
    )
  in
  let seconds = load-int(time-struct) in
  let nanoseconds = load-int(add-int(time-struct, 8)) in
  if ge-int32(result, 0) {
    Pass(Time of {seconds, nanoseconds})
  } else {
    none()
  }
}

define show-time(m: time): text {
  let Time of {seconds = s, nanoseconds = ns} = m in
  format("{}{}", [%ld(s), _format-nanoseconds(ns, 9)])
}

define _time-as-int(m: time): int {
  let Time of {seconds = s, nanoseconds = ns} = m in
  if lt-int(0, s) {
    add-int(mul-int(s, 1000000000), ns)
  } else {
    let s' = mul-int(-1, s) in
    mul-int(-1, add-int(mul-int(s', 1000000000), ns))
  }
}

define add-time(m1: time, m2: time): time {
  let v1 = _time-as-int(m1) in
  let v2 = _time-as-int(m2) in
  let v = add-int(v1, v2) in
  Time of {
    seconds = div-int(v, 1000000000),
    nanoseconds = abs-int(rem-int(v, 1000000000)),
  }
}

define sub-time(m1: time, m2: time): time {
  let Time of {seconds = s2, nanoseconds = ns2} = m2 in
  add-time(m1, Time of {seconds = mul-int(-1, s2), nanoseconds = ns2})
}

inline _cmp-time(m1: time, m2: time, cmp: (int, int) -> bool): bool {
  let Time of {seconds = s1, nanoseconds = ns1} = m1 in
  let Time of {seconds = s2, nanoseconds = ns2} = m2 in
  if cmp(s1, s2) {
    cmp(ns1, ns2)
  } else {
    False
  }
}

define eq-time(m1: time, m2: time): bool {
  _cmp-time(m1, m2, eq-int)
}

define lt-time(m1: time, m2: time): bool {
  _cmp-time(m1, m2, lt-int)
}

define le-time(m1: time, m2: time): bool {
  _cmp-time(m1, m2, le-int)
}

define gt-time(m1: time, m2: time): bool {
  _cmp-time(m1, m2, gt-int)
}

define ge-time(m1: time, m2: time): bool {
  _cmp-time(m1, m2, ge-int)
}

define now(): text {
  to-ISO8601-local(get-time(), 6)
}

define zen(): unit {
  let test-ts = Time of {seconds = 123453234, nanoseconds = 56789} in
  let Clock of {minutes, seconds} = to-UTC-clock(test-ts) in
  printf("{}\n", [to-ISO8601-UTC(test-ts, 6)]);
  printf("minutes: {}, seconds: {}\n", [%ld(minutes), %ld(seconds)]);
  match from-ISO8601("2024-05-27T11:11:40.553393+09:00") {
  | Pass(ts) =>
    printf("{}\n", [to-ISO8601-UTC(ts, 6)])
  | Fail(_) =>
    print("failed to parse\n")
  }
}

define main(): unit {
  zen()
}
